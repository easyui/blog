# Go Tips


## :smile:bin: 目录里面存放的都是通过 go install 命令安装后，由 Go 命令源码文件生成的可执行文件。
有两种情况下，bin 目录会变得没有意义。

当设置了有效的 GOBIN 环境变量以后，bin 目录就变得没有意义。

如果 GOPATH 里面包含多个工作区路径的时候，必须设置 GOBIN 环境变量，否则就无法安装 Go 程序的可执行文件。

## :smile:Go 语言在多个工作区中查找依赖包的时候是以怎样的顺序进行的？
如果有多个工作区，那么是按照GOPATH里面的先后顺序查找的

## :smile:如果在多个工作区中都存在导入路径相同的代码包会产生冲突吗
不会冲突，那么是按照GOPATH里面的先后顺序查找的

## :smile:代码包的名称一般会与源码文件所在的目录同名。如果不同，import的还是目录名，代码中使用的包名。因为GOPATH的特性，只会按照目录来查找包，但你调用的时候就不能用目录名字来调用了。
在工作区中，一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相对路径。

## :smile:安装某个代码包而产生的归档文件或可执行文件是与这个代码包同名的。

## :smile: Package flag
```go
我试着把参数增加到两个，然后试试运行结果
func init() {
  flag.StringVar(&name, "name1", "ladies", "The greeting object 1")
  flag.StringVar(&name, "name2", "gentlemen", "The greeting object 2")
}

# go run test.go
Hello gentlemen!
和想像的一样，name2的默认值覆盖了name1的默认值

# go run test.go -name1=Robert
Hello Robert!
和想像的略有不同，只指定了name1，没有指定name2，输出了name1的指定值，name2的默认值没有生效

# go run test.go -name2=Jose
Hello Jose!
没毛病

# go run test.go -name1=Robert -name2=Jose
Hello Jose!
没毛病

# go run test.go -name2=Jose -name1=Robert
Hello Robert!
这有点奇怪了，输出的值是以参数的先后顺序为准的，而不是以flag.StringVar函数的顺序为准的
```
